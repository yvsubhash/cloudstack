// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
// Automatically generated by addcopyright.py at 01/29/2013
// Apache License, Version 2.0 (the "License"); you may not use this
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// Automatically generated by addcopyright.py at 04/03/2012
package com.cloud.wds.networkservice;

import com.cloud.agent.AgentManager;
import com.cloud.agent.api.Answer;
import com.cloud.api.query.dao.TemplateJoinDao;
import com.cloud.api.query.vo.TemplateJoinVO;
import com.cloud.baremetal.database.BaremetalPxeVO;
import com.cloud.baremetal.manager.BareMetalTemplateAdapter;
import com.cloud.baremetal.networkservice.BaremetalPxeManager;
import com.cloud.configuration.Resource;
import com.cloud.exception.AgentUnavailableException;
import com.cloud.exception.OperationCancelledException;
import com.cloud.exception.OperationTimedoutException;
import com.cloud.network.dao.PhysicalNetworkVO;
import com.cloud.storage.DataStoreRole;
import com.cloud.storage.TemplateProfile;
import com.cloud.storage.VMTemplateDetailVO;
import com.cloud.storage.VMTemplateStorageResourceAssoc;
import com.cloud.storage.VMTemplateVO;
import com.cloud.storage.dao.VMTemplateDao;
import com.cloud.storage.dao.VMTemplateDetailsDao;
import com.cloud.template.TemplateAdapter;
import com.cloud.template.VirtualMachineTemplate;
import com.cloud.utils.StringUtils;
import com.cloud.utils.db.QueryBuilder;
import com.cloud.utils.db.SearchBuilder;
import com.cloud.utils.db.SearchCriteria;
import com.cloud.utils.exception.CloudRuntimeException;
import com.cloud.wds.api.ImportImageCommand;
import com.cloud.wds.api.RemoveImageCommand;
import com.cloud.wds.template.CallbackContext;
import com.cloud.wds.template.PollingExecutor;
import org.apache.cloudstack.engine.subsystem.api.storage.ObjectInDataStoreStateMachine;
import org.apache.cloudstack.framework.async.AsyncCallbackDispatcher;
import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreDao;
import org.apache.cloudstack.storage.datastore.db.TemplateDataStoreVO;
import org.apache.log4j.Logger;

import javax.ejb.Local;
import javax.inject.Inject;
import javax.naming.ConfigurationException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.Map;

/**
 * Created by Raghav on 8/13/2015.
 */
@Local(value = TemplateAdapter.class)
public class WdsTemplateAdapter extends BareMetalTemplateAdapter {

    public enum WdsTemplateParams {
        InstallImageFile, BootImageFile, BootImageName, InstallImageName, ClientUnattendFile, ImageUnattendFile, ImageGroupName, Architecture, SingleImageName
    }

    public enum WdsPrestageParams {
        WdsClientUnattend, BootImagePath
    }

    public enum WdsAnswerCallbackParams {
        inProgress
    }

    public enum WdsAgentResponse {
        InProgress, Pass, Fail
    }

    public enum WdsVmDataParams {
        VMData
    }

    private final static Logger s_logger = Logger.getLogger(WdsTemplateAdapter.class);

    @Inject
    TemplateDataStoreDao _templateDataStoreDao;
    @Inject
    VMTemplateDao _vmTemplateDao;
    @Inject
    VMTemplateDetailsDao _vmTemplateDetailsDao;
    @Inject
    AgentManager _agentManager;
    @Inject
    TemplateJoinDao _templateJoinDao;

    private SearchBuilder<TemplateJoinVO> templateSearchByDetailValue;

    @Override
    public boolean configure(String name, Map<String, Object> params) throws ConfigurationException {
        templateSearchByDetailValue = _templateJoinDao.createSearchBuilder();
        templateSearchByDetailValue.and("detailName", templateSearchByDetailValue.entity().getDetailName(), SearchCriteria.Op.IN);
        templateSearchByDetailValue.and("detailValue", templateSearchByDetailValue.entity().getDetailValue(), SearchCriteria.Op.IN);
        templateSearchByDetailValue.done();
        return super.configure(name, params);
    }

    @Override
    public String getName() {
        return "WDS";
    }

    @Override
    public VMTemplateVO create(TemplateProfile profile) {
        List<Long> zoneIds = profile.getZoneIdList();

        if (zoneIds == null || zoneIds.size() > 1) {
            throw new CloudRuntimeException("WDS images can only be registered to a specific zone, please pass only one zone id");
        }

        Long zoneId = zoneIds.get(0);

        Map<String, String> templateDetails = profile.getDetails();

        List<String> detailValues = new ArrayList<>();

        for(WdsTemplateParams param : WdsTemplateParams.values()) { //think of reusing existing boot.wim and unattend xml
            // if param missing or has blank value
            String value = templateDetails.get(param.toString());
            if(!StringUtils.isNotBlank(value)) {
                throw new CloudRuntimeException("Required template detail " + param.toString() + " is missing");
            }

            if(param.equals(WdsTemplateParams.ClientUnattendFile)) {
                if(!value.endsWith(".xml")) {
                    throw new CloudRuntimeException(".xml extension is required for " + WdsTemplateParams.ClientUnattendFile.toString());
                }
                detailValues.add(value);
            } else if(param.equals(WdsTemplateParams.ImageUnattendFile)) {
                if(!value.endsWith(".xml")) {
                    throw new CloudRuntimeException(".xml extension is required for " + WdsTemplateParams.ImageUnattendFile.toString());
                }
            } else if(param.equals(WdsTemplateParams.InstallImageFile)) {
                if(!value.endsWith(".wim")) {
                    throw new CloudRuntimeException(".wim extension is required for " + WdsTemplateParams.InstallImageFile.toString());
                }
            } else if(param.equals(WdsTemplateParams.BootImageFile)) {
                if(!value.endsWith(".wim")) {
                    throw new CloudRuntimeException(".wim extension is required for " + WdsTemplateParams.BootImageFile.toString());
                }
            } else if(param.equals(WdsTemplateParams.Architecture)) {
                if(!(value.equals("x86") || value.equals("x64"))) {
                    throw new CloudRuntimeException("only x86 and x64 architectures are supported");
                }
            } else if(param.equals(WdsTemplateParams.BootImageName)) {
                detailValues.add(value);
            } else if(param.equals(WdsTemplateParams.InstallImageName)) {
                detailValues.add(value);
            }

        }

        String[] detailNames = { WdsTemplateParams.ClientUnattendFile.toString(), WdsTemplateParams.BootImageName.toString(), WdsTemplateParams.InstallImageName.toString() };

        SearchCriteria<TemplateJoinVO> templateCriteria = templateSearchByDetailValue.create();
        templateCriteria.setParameters("detailName", detailNames);
        templateCriteria.setParameters("detailValue", detailValues.toArray());

        List<TemplateJoinVO> existingTemplates = _templateJoinDao.customSearch(templateCriteria, null);

        if(existingTemplates != null && !existingTemplates.isEmpty()) {
            for(TemplateJoinVO existingTemplate : existingTemplates) {
                String newTemplateValue = templateDetails.get(existingTemplate.getDetailName());
                if(newTemplateValue.equals(existingTemplate.getDetailValue())) {
                    ObjectInDataStoreStateMachine.State existingTemplateState = existingTemplate.getState();
                    if(!existingTemplateState.equals(ObjectInDataStoreStateMachine.State.Destroying) && !existingTemplateState.equals(ObjectInDataStoreStateMachine.State.Destroyed) && !existingTemplateState.equals(ObjectInDataStoreStateMachine.State.Failed)) {
                        throw new CloudRuntimeException("Template with name: " + existingTemplate.getName() + " with id: " + existingTemplate.getId() + " already has detail: " + existingTemplate.getDetailName() + " with value: " + existingTemplate.getDetailValue());
                    }
                }
            }
        }

        QueryBuilder<PhysicalNetworkVO> pnsc = QueryBuilder.create(PhysicalNetworkVO.class);
        pnsc.and(pnsc.entity().getDataCenterId(), SearchCriteria.Op.EQ, zoneId);
        PhysicalNetworkVO physicalNetwork = pnsc.find();

        QueryBuilder<BaremetalPxeVO> sc = QueryBuilder.create(BaremetalPxeVO.class);
        sc.and(sc.entity().getPhysicalNetworkId(), SearchCriteria.Op.EQ, physicalNetwork.getId());
        List<BaremetalPxeVO> baremetalPxeVOs = sc.list();

        if(baremetalPxeVOs == null || baremetalPxeVOs.isEmpty()) {
            throw new CloudRuntimeException("No PXE servers in the zone");
        }

        for(BaremetalPxeVO pxeVO : baremetalPxeVOs) {
            if(!pxeVO.getDeviceType().equalsIgnoreCase(BaremetalPxeManager.BaremetalPxeType.WDS.toString())) {
                throw new CloudRuntimeException("Non WDS PXE found in zone, cannot register template");
            }
        }

        VMTemplateVO template = persistTemplate(profile, VirtualMachineTemplate.State.Inactive);

        _vmTemplateDao.loadDetails(template);

        for(BaremetalPxeVO pxeVO : baremetalPxeVOs) {
            TemplateDataStoreVO vmTemplateHost = new TemplateDataStoreVO(pxeVO.getHostId(), template.getId(), new Date(), 0, VMTemplateStorageResourceAssoc.Status.NOT_DOWNLOADED, null, null, null, null, template.getUrl());
            vmTemplateHost.setDataStoreRole(DataStoreRole.Image); // add this to get state in template_view
            _tmpltStoreDao.persist(vmTemplateHost);
        }

        templateCreateUsage(template, zoneId);

        _resourceLimitMgr.incrementResourceCount(profile.getAccountId(), Resource.ResourceType.template);

        for(BaremetalPxeVO pxe : baremetalPxeVOs) {
            importImageInWDS(template, pxe.getHostId());
        }

        return template;

    }

    @Override
    public boolean delete(TemplateProfile profile) {
        VMTemplateVO template = profile.getTemplate();
        _vmTemplateDao.loadDetails(template);
        List<TemplateDataStoreVO> templateDataStoreVOs = _tmpltStoreDao.listByTemplate(template.getId());

        boolean status = false;

        for(TemplateDataStoreVO templateDataStoreVO : templateDataStoreVOs) {
            try {
                Answer answer = removeImageFromWDS(template, templateDataStoreVO.getDataStoreId());
                status = status || answer.getResult(); // true even if succeeds in one of the WDS server
            } catch (Exception e) {
                s_logger.error("error during deletion of template: " + template.getName() + " on host with id: " + templateDataStoreVO.getDataStoreId(), e);
            }
        }

        if(status) {
            status = status && super.delete(profile);
        } else {
            s_logger.error("error during deletion of template: " + template.getName());
        }

        return status;
    }

    public void importImageInWDS(VMTemplateVO template, Long hostId) {
        Map<String, String> templateDetails = template.getDetails();

        String installImageFile = templateDetails.get(WdsTemplateParams.InstallImageFile.toString());
        String bootImageFile = templateDetails.get(WdsTemplateParams.BootImageFile.toString());
        String bootImageName = templateDetails.get(WdsTemplateParams.BootImageName.toString());
        String installImageName = templateDetails.get(WdsTemplateParams.InstallImageName.toString());
        String clientUnattendFile = templateDetails.get(WdsTemplateParams.ClientUnattendFile.toString());
        String imageUnattendFile = templateDetails.get(WdsTemplateParams.ImageUnattendFile.toString());
        String imageGroupName = templateDetails.get(WdsTemplateParams.ImageGroupName.toString());
        String architecture = templateDetails.get(WdsTemplateParams.Architecture.toString());
        String singleImageName = templateDetails.get(WdsTemplateParams.SingleImageName.toString());

        ImportImageCommand cmd = new ImportImageCommand(installImageFile, bootImageFile, bootImageName, installImageName, clientUnattendFile, imageUnattendFile, imageGroupName, architecture, singleImageName, template.getId(), hostId);
        CallbackContext<Answer> context = new CallbackContext<>(null, template.getId(), hostId);
        AsyncCallbackDispatcher<WdsTemplateAdapter, Answer> caller = AsyncCallbackDispatcher.create(this);
        caller.setCallback(caller.getTarget().registerImageAsyncCallBack(null, null));
        caller.setContext(context);

        PollingExecutor<WdsTemplateAdapter> executor = new PollingExecutor<>(cmd, hostId, caller, _agentManager);
        executor.start();
    }

    public Answer removeImageFromWDS(VMTemplateVO template, Long hostId) throws AgentUnavailableException,
            OperationTimedoutException, OperationCancelledException {
        Map<String, String> templateDetails = template.getDetails();

        String installImageFile = templateDetails.get(WdsTemplateParams.InstallImageFile.toString());
        String bootImageFile = templateDetails.get(WdsTemplateParams.BootImageFile.toString());
        String bootImageName = templateDetails.get(WdsTemplateParams.BootImageName.toString());
        String installImageName = templateDetails.get(WdsTemplateParams.InstallImageName.toString());
        String clientUnattendFile = templateDetails.get(WdsTemplateParams.ClientUnattendFile.toString());
        String imageGroupName = templateDetails.get(WdsTemplateParams.ImageGroupName.toString());
        String architecture = templateDetails.get(WdsTemplateParams.Architecture.toString());

        RemoveImageCommand cmd = new RemoveImageCommand(installImageName, bootImageName, imageGroupName, installImageFile, bootImageFile, clientUnattendFile, architecture, template.getId(), hostId);
        return _agentManager.send(hostId, cmd);
    }

    protected Void registerImageAsyncCallBack(AsyncCallbackDispatcher<WdsTemplateAdapter, Answer> callback,
                                              CallbackContext<Answer> context) {

        synchronized (this) { //this is important

            Answer answer = callback.getResult();

            Long hostId = context.getHostId();
            Long templateId = context.getTemplateId();

            QueryBuilder<TemplateDataStoreVO> tsc = QueryBuilder.create(TemplateDataStoreVO.class);
            tsc.and(tsc.entity().getDataStoreId(), SearchCriteria.Op.EQ, hostId);
            tsc.and(tsc.entity().getTemplateId(), SearchCriteria.Op.EQ, templateId);
            TemplateDataStoreVO template = tsc.find();

            Map<String, String> templateDetails =_vmTemplateDetailsDao.listDetailsKeyPairs(templateId);

            if(answer.getResult()) {

                if(!templateDetails.containsKey(WdsPrestageParams.WdsClientUnattend.toString())) {
                    String wdsClientUnattend = answer.getContextParam(WdsPrestageParams.WdsClientUnattend.toString());
                    VMTemplateDetailVO wdsUnattendDetailVO = new VMTemplateDetailVO(templateId, WdsPrestageParams.WdsClientUnattend.toString(), wdsClientUnattend, true);
                    _vmTemplateDetailsDao.persist(wdsUnattendDetailVO);
                }

                if(!templateDetails.containsKey(WdsPrestageParams.BootImagePath.toString())) {
                    String bootImagePath = answer.getContextParam(WdsPrestageParams.BootImagePath.toString());
                    VMTemplateDetailVO bootImageVO = new VMTemplateDetailVO(templateId, WdsPrestageParams.BootImagePath.toString(), bootImagePath, true);
                    _vmTemplateDetailsDao.persist(bootImageVO);
                }

                template.setState(ObjectInDataStoreStateMachine.State.Ready);
                template.setDownloadPercent(100);
                template.setDownloadState(VMTemplateStorageResourceAssoc.Status.DOWNLOADED);
            } else {
                s_logger.error("error during template import: " + answer.getDetails());
                template.setState(ObjectInDataStoreStateMachine.State.Failed);
            }

            _templateDataStoreDao.update(template.getId(), template);

            //after update query to check if import failed in any of the hosts

            QueryBuilder<TemplateDataStoreVO> sc = QueryBuilder.create(TemplateDataStoreVO.class);
            sc.and(sc.entity().getTemplateId(), SearchCriteria.Op.EQ, templateId);
            List<TemplateDataStoreVO> templates = sc.list();

            boolean isImportInProgressForAnyHost = false;
            boolean isImportErrorForAnyHost = false;

            List<TemplateDataStoreVO> successfullyImportedImages = new ArrayList<>();

            for(TemplateDataStoreVO vo : templates) {
                if(vo.getState().equals(ObjectInDataStoreStateMachine.State.Allocated)) {
                    isImportInProgressForAnyHost = true;
                    break;
                }

                if(vo.getState().equals(ObjectInDataStoreStateMachine.State.Failed)) {
                    isImportErrorForAnyHost = true;
                }

                if(vo.getState().equals(ObjectInDataStoreStateMachine.State.Ready)) {
                    successfullyImportedImages.add(vo);
                }
            }

            if(!isImportInProgressForAnyHost) { // do nothing if import is in progress, let every import complete and then the last thread will take care of updating

                if(isImportErrorForAnyHost) { // import error for some host, trigger delete on successful hosts
                    for(TemplateDataStoreVO tempVO: successfullyImportedImages) {
                        VMTemplateVO templateVO = _vmTemplateDao.findById(tempVO.getTemplateId());
                        _vmTemplateDao.loadDetails(templateVO);
                        try {
                            Answer ans = removeImageFromWDS(templateVO, tempVO.getDataStoreId());
                            if(!ans.getResult()) {
                                s_logger.error("error during deletion of template: " + templateVO.getName() + " on host with id: " + tempVO.getDataStoreId());
                            }
                        } catch (AgentUnavailableException | OperationTimedoutException | OperationCancelledException e) {
                            s_logger.error("error during deletion of template: " + templateVO.getName() + " on host with id: " + tempVO.getDataStoreId(), e);
                        }
                    }
                } else { // import successful on all hosts mark template as active
                    VMTemplateVO vmTemplate = _vmTemplateDao.findById(template.getTemplateId());
                    vmTemplate.setState(VirtualMachineTemplate.State.Active);
                    _vmTemplateDao.update(vmTemplate.getId(), vmTemplate);
                }

            }

        }

        return null;
    }
}
